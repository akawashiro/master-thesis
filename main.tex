% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\newif\ifnotanonymous \notanonymoustrue
\newif\iffullversion \fullversiontrue
\documentclass[master,english]{kuisthesis}
%
\usepackage{graphicx}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bcprules, proof}
\usepackage{fancybox}
\usepackage{mathtools}
\usepackage{float}
\usepackage{xparse}
\usepackage{lscape}
\usepackage{xspace}
\usepackage{url}
\usepackage{bcpproof}
\usepackage{multicol}

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{cite}
\usepackage{hyperref}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\newcommand{\red}[1]{\textcolor{red}{#1 }}
\newcommand{\blue}[1]{\textcolor{blue}{#1 }}

\input{fig-src/symbols.tex}

\newcommand{\rulefbox}[1]{\fbox{\ensuremath{#1}} \hspace{1mm}}

\newcommand{\AI}[1]{\textcolor{red}{[#1 -- AI]}}
\newcommand{\AK}[1]{\textcolor{blue}{[#1 -- AK]}}
\newcommand{\RESUME}{\AK{========== RESUME HERE ==========}}

\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}

\begin{document}

\jtitle{依存型を含む多段階計算体型}
\etitle{A Dependently Typed Multi-Stage Calculus}
\jauthor{河田 旺}				% Author name in Japanese
\eauthor{Akira Kawata}			% Author name in English
\supervisor{Professor Atsushi Igarashi}		% Name of your Supervisor
\date{February 15, 2020}			% Submission date
\department{Communications and Computer Engineering}			% Dept. name

\maketitle

\begin{eabstract}

% Merits of multi-stage programming

Multi-stage programming is a programming paradigm that enables generation and evaluation of code at run-time. For instance, MetaOCaml, which is
a well-known multi-stage programming language supporting quasi-quotation and
cross-stage persistence for the manipulation of code fragments as first-class
values and an evaluation construct for the execution of programs dynamically
generated by code manipulation. A significant merit of multi-stage
programming is the utilization of run-time information during code generation. For
example, we can generate an efficient vector sum function for arbitrary
fixed-length vectors by unrolling loops.

% Problems of multi-stage programming

However, such optimization may cause severe problems because specialized
functions only can be used with restricted arguments. In the case of a vector
addition function, the generated function is specialized for the given
length, and must be used with vectors of the correct length. Otherwise, the
function can access outside of vectors because the loop-unrolled code never
checks the boundaries of its input.

% Our solution for the problem

To resolve the above problem, we study a dependently typed extension of a
multi-stage programming language \`a la MetaOCaml. Dependent types bring to
multi-stage programming the enforcement of strong invariants---beyond simple
type safety---on the behavior of dynamically generated code. In the case of
the vector sum function, dependent types restrict the input arguments to vectors of the correct length. However, extending multi-stage programming
with dependent types is non-trivial because such a type system must
integrate stages of types, which is the number of surrounding quotations.

% Our contibution

To rigorously study properties of such an extension, we develop \LMD, which is
an extension of typed calculus \LTP proposed by Hanada and Igarashi with
dependent types, and prove its properties, including preservation,
confluence, strong normalization for full reduction, and progress for
staged reduction.  Furthermore, we design algorithmic typing to implement a
type-checker and prove its equivalence to the original typing. 

% Following sentence may be too technical.

    % Motivated by code generators that generate code whose type depends on a
    % value from outside of the quotations, we argue the significance of CSP in
    % dependently typed multi-stage programming and certain type equivalences
    % that are not directly derived from reduction rules. 

\end{eabstract}

\begin{jabstract}				% Abstract in Japanese
    他段階計算は実行時におけるコードの生成、評価を可能にするプログラミング手法である。例えば、他段階計算を使用なMetaOCamlではコードの生成、埋め込み、他段階埋め込み(Cross-Stage Persistence)、コードの実行が利用可能である。他段階計算の特筆すべき利点は実行時情報をコードの生成に利用できる点にある。例えば、任意長のベクトルの和を計算する関数をループを展開した関数を生成することで高速化できる。
    しかし、このような高速化には生成された関数が限定された引数しか受け取れないという弊害もある。ベクトル和を計算する関数の場合、生成された関数は特定の長さに特殊化されており、その長さのベクトルに対して適用することはできない。適用した場合、関数はベクトルの範囲外にアクセスしているかどうかを検査しないので、ベクトルの範囲外のメモリ領域にアクセスしてしまうことがある。
    この問題を解決するために、我々はMetaOCaml風の依存型付他段階計算体型を提案する。依存型は他段階計算に単純型を超えたより強いコードの振る舞いに対する不変条件を与える。ベクトル和を求める関数の場合、引数の長さは依存型によって適格なものだけに制限される。しかし、ステージ、つまりある式の周りの引用符の数、を型システムに組み込む必要があり、依存型による他段階計算体型の拡張は自明ではなかった。
    このような性質を厳密に研究するため、私達は 花田、五十嵐による \LTP を拡張子 \LMD を提案する。そして、この体型について保存性、合流性、full reduction に対する強正規化性とステージを考慮した簡約における進行性を示した。更に、私達は \LMD の型推論器を設計するのに必要な algorithmic typing も設計し、その規則が元の型付け規則と同値であることを示した。
\end{jabstract}

\tableofcontents				% Output table of contents

\input{main-src/introduction.tex}

\input{main-src/informal-overview.tex}

\input{main-src/formal-definition.tex}

\input{main-src/properties.tex}

\input{main-src/related-work.tex}

\input{main-src/conclusion.tex}

\input{main-src/acknowledgments.tex}

\bibliographystyle{kuisunsrt}
\bibliography{main}

\Appendix

%\newtheorem{thm}{Theorem}
\newtheorem{dfn}{Definition}
\newtheorem{ex}{Example}
\newtheorem{cm}{Comment}
\newcommand{\figheader}[2]{
  \begin{flushleft}
    #2 {\bf \normalsize #1}
\end{flushleft}}

\section{Full Definition of \LMD}
\input{main-src/fulldefinitions}

\AK{Should I include the details of proofs?}

% \section{Proofs}
% \input{main-src/proofs}

\end{document}
