\documentclass[dvipdfmx,aspectratio=169, 20pt]{beamer}
\usepackage[absolute,overlay]{textpos}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{ascmac}
\usepackage[backend=biber, style=numeric]{biblatex}
\usepackage{color}
\usepackage{mathtools}
\usepackage{url}
\usepackage{bcprules, proof}
\usepackage{xparse}
\usepackage{xspace}
\usepackage{fancybox}
\usepackage{fancyvrb}
\usepackage{float}
\usepackage{bcprules}
\usepackage{ebproof}
\usepackage{lscape}
\usepackage{pgfpages}
\usepackage{bm}
\usepackage{tikz}
\usetikzlibrary{positioning}

% beamer cheat sheet
% http://www.cpt.univ-mrs.fr/~masson/latex/Beamer-appearance-cheat-sheet.pdf

% Make Japanese font gothic
\renewcommand{\kanjifamilydefault}{\gtdefault}

% Make note pages suer simple.
% \setbeamertemplate{note page}[plain]

% This option generate pdf files showing notes on the right hand side of each
% pages. But this optionn has some bugs. I recommend you not to use this
% option.
% \setbeameroption{show notes on second screen=right}

% Note options
% Show plain text in note pages.
\setbeamertemplate{note page}[plain]
% Show / hide note
% \setbeameroption{show notes}
% \setbeameroption{hide notes}
% \setbeameroption{show only notes}

% Show grid for debug
% \setbeamertemplate{background}[grid][step=1cm]

% Use default design theme. I quit to use this theme because it has no boxed
% environments.
% \usetheme{default}
\usetheme{Boadilla}

% Add page numbers to footnotes. This line does not work for Boadilla theme.
% \setbeamertemplate{footline}[frame number]

% So, I use some hack in
% https://tex.stackexchange.com/questions/66995/modify-footer-of-slides.
% \makeatother and \makeatletter enable us to change internal package things.
\makeatother
\setbeamertemplate{footline}
{
    \leavevmode
    \hbox{
        \setbeamercolor{coloredboxstuff}{fg=black,bg=white}
        \hskip0.85\paperwidth
        \begin{beamercolorbox}[wd=0.10\paperwidth,ht=2.25ex,dp=1ex,right]{coloredboxstuff}
            {\textbf{\insertframenumber{} / \inserttotalframenumber}}
        \end{beamercolorbox}}
    \vskip0pt
}
\makeatletter

% Remove all navigation symbols
\setbeamertemplate{navigation symbols}{}
% using non standard fonts for beamer
\usefonttheme{professionalfonts}
% Set the font size of titles
% See other font category at
% https://tex.stackexchange.com/questions/183052/what-are-all-the-possible-first-arguments-to-setbeamerfont
\setbeamerfont{title}{size=\normalsize}
\setbeamerfont{frametitle}{size=\normalsize}
\setbeamerfont{normal text}{size=\small}
\setbeamerfont{itemize/enumerate body}{size=\small}
\setbeamerfont{itemize/enumerate subbody}{size=\small}
\setbeamerfont{frametitle continuation}{size=\small}
\setbeamerfont{framesubtitle}{size=\small}
\setbeamerfont{abstract}{size=\small}
\setbeamerfont{projected text}{size=\small}
\setbeamerfont{block title}{size=\small}
\setbeamerfont{footline}{size=\tiny}
\setbeamerfont{note page}{size=\scriptsize}

% You need this line in order to enforce normal text font setting.
% https://tex.stackexchange.com/questions/320223/how-to-enforce-a-font-series-in-beamer-for-normal-default-text
\AtBeginDocument{\usebeamerfont{normal text}}

% Settings of Table of Contents page.
% Append underline to currentsection.
% https://tex.stackexchange.com/questions/280813/beamer-change-color-underline-but-do-not-hide-shade-other-section-in-table-of-c/283585
% https://tex.stackexchange.com/questions/414250/numbers-shading-and-alert-in-beamer-table-of-contents
% Page 101 of http://tug.ctan.org/macros/latex/contrib/beamer/doc/beameruserguide.pdf
\setbeamertemplate{section in toc}{
    \inserttocsectionnumber.\ \bf{\underline{\inserttocsection}}
}
\setbeamertemplate{section in toc shaded}{
    \inserttocsectionnumber.\  \inserttocsection
}

\setbeamertemplate{bibliography item}{\insertbiblabel}
% \setbeamertemplate{blocks}[default]
\setbeamertemplate{blocks}[rounded]
\setbeamertemplate{theorems}[normal font]

% \bibliography{main}{}
\addbibresource{main.bib}
\DeclareSortingScheme{mysorting}{\sort{\citeorder}}
\ExecuteBibliographyOptions{sorting=mysorting}

\setlength\intextsep{0pt}
\setlength\textfloatsep{0pt}

\newcommand{\rulefbox}[1]{\fbox{\ensuremath{#1}} \hspace{1mm}}
\newcommand{\figheader}[2]{
  \begin{flushleft}
    #2 {\bf \normalsize #1}
\end{flushleft}}

\defbeamertemplate{description item}{align left}{\insertdescriptionitem\hfill}

% Load symbol macros
\input{symboldef.tex}

% I don't use sigma in this slides.
\renewcommand{\V}{\vdash}

\title{依存型付多段階計算体系}
\subtitle{Dependently Typed Multi-stage Calculus}
\author{河田 旺}
\institute{五十嵐・末永研究室}
\date{2020年2月12日}

\begin{document}
\maketitle

% This blank page is for seeing notes easily.
% \begin{frame}{}
% \end{frame}

% Output the outline slide
% \begin{frame}{Contents}
%     \tableofcontents[currentsection]
%   \note{
%   }
% \end{frame}

\section{背景}

% \begin{frame}{目次}
%
%     \setbeamertemplate{section in toc}{
%         \inserttocsectionnumber.\ \inserttocsection
%     }
%
%     \tableofcontents
% \end{frame}

\begin{frame}[fragile]{多段階計算とはなにか}
    以下の2つを可能にするプログラミング手法
    \begin{itemize}
        \item 実行時のコード生成
        \item 生成したコードの実行
    \end{itemize}
    応用例
    \begin{itemize}
        \item 実行時の情報を使ったプログラムの高速化
        \item 領域特化言語(DSL)
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{MetaOCamlによる多段階計算の例1}
    \( \TB \) でコードの生成 ( \( \TW \)\ \verb|int| はint型のコードの型)
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 # let a = $\TB$ (1 + 2)
 val a : $\TW$ int = $\TB$ (1 + 2)
        \end{Verbatim}
    \end{exampleblock}
    \( \TBL \)で、生成したコードを他のコードに埋め込める
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 # let b = $\TB$ (($\TBL$ a) + ($\TBL$ a))
 val b : $\TW$ int = $\TB$ ((1 + 2) + (1 + 2))
        \end{Verbatim}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{MetaOCamlによる多段階計算の例2}
    \verb|run| でコードの実行
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 # run ($\TB$ (1 + 2))
 - : int = 3
 # run b
 - : int = 6
        \end{Verbatim}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{多段階計算の応用例: vadd-gen}
    ベクトルの長さを受け取って、\\その長さのベクトルを足し合わせる関数を作る関数
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 val vadd-gen : int -> $\TW$ (vec -> vec -> vec)
 # let vadd3 = vadd-gen 3
 val vadd3 : $\TW$ (vec -> vec -> vec)
           = $\TB$ (fun v w ->
             [v[0]+w[0];v[1]+w[1];v[2]+w[2]])
    \end{Verbatim}
    \end{exampleblock}
    吹き出し「ループが展開されて処理速度があがっている」
\end{frame}

\begin{frame}[fragile]{vadd-genによって生成されたvadd3の問題点}
    誤った長さのベクトルを渡すと実行時エラーが起きる
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 val vadd3 : $\TW$ (vec -> vec -> vec)
 # (run vadd3) [1;2;3] [4;5;6]
 - : vec = [5;7;9]
 # (run vadd3) [1;2] [4;5]
 ---> 実行時エラー発生
    \end{Verbatim}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{アイデア: 依存型の導入}
    \renewcommand{\V}{\text{vec}\ }
    ベクトルの長さを表現できる型を導入する
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 [1;2]: vec 2
 vadd3 : $\TW$ (vec 3 -> vec 3 -> vec 3)

 # (run vadd3) [1;2] [4;5]
 ---> 実行する前に型で誤りを検知
 \end{Verbatim}
    \end{exampleblock}
    吹き出し「\verb|vec 2| \( \neq \) \verb|vec 3|」
\end{frame}

\begin{frame}[fragile]{依存型[Martin-L{\"o}f'73]とは}
    \renewcommand{\V}{\text{vec}\ }
    依存型とは式をパラメータとして渡せる型
    \begin{exampleblock}{}
        \begin{Verbatim}
 [1;2]: vec 2      // ベクトルの長さを表現できる
        \end{Verbatim}
    \end{exampleblock}
    \begin{exampleblock}{}
        \begin{Verbatim}
 vec (1+2)         // vec に (1+2) という式を
                   // パラメータとして渡せる
 \end{Verbatim}
    \end{exampleblock}
    \begin{exampleblock}{}
        \begin{Verbatim}
 append: vec n -> vec m -> vec (n + m)
 append [1;2] [3;4;5]: vec 5 
        \end{Verbatim}
    \end{exampleblock}
% \begin{tikzpicture}[remember picture, overlay]
%     \node[rectangle callout, fill=red!80, white, callout absolute pointer={(bgraph.north)}, above=of bgraph]{2部グラフ}; %
% \end{tikzpicture}
\end{frame}

\begin{frame}[fragile]{本研究の貢献: \LMD}
    既存の多段階計算体系 \LTP [Hanada\&Igarashi'14] を拡張して
    依存型付多段階計算体系 \LMD を設計した
    \begin{itemize}
        \item 多段階計算の機能
        \item 依存型の機能
    \end{itemize}
    技術的な貢献
    \begin{itemize}
        \item 型安全性の証明
        \item 型推論アルゴリズムの設計と正当性の証明
    \end{itemize}
\end{frame}

% \section{既存の多段階計算体系 \LTP}

% \begin{frame}{目次}
%     \tableofcontents[currentsection]
% \end{frame}

% \begin{frame}[fragile]{\LTP [Hanada\&Igarashi'14] の概観}
%     \begin{table}
%         \begin{tabular}{ c | c | c }
%             & \LTP & MetaOCaml \\[2mm]
%             \hline
%             コードの作成 & \( \textbf{let } a = \TB (1 + 2) \) & \verb| let a = <(1+2)> | \\[2mm]
%             コードの埋め込み & \( (\TB (\TBL a + \TBL a)) \) & \verb| <(~a)+(~a)> | \\[2mm]
%             コード型 & \( \TW\ \text{int} \) & \verb| int code |
%         \end{tabular}
%     \end{table}
% \end{frame}

% \begin{frame}[fragile]{\LTP とは}
%     \begin{itemize}
%         \item Hanada, Igarashi による多段階計算体系
%         \item ステージを跨ぐコードの埋め込み(CSP)が可能
%         \item 今回の研究の拡張元
%     \end{itemize}
% \end{frame}

\begin{frame}[fragile]{\LMD の項}
    \begin{block}{項}
        \begin{tabbing}
            \hspace{5mm} \( M \) \= \( ::= c \) \hspace{20mm} \= (定数) \\
            \> \( \mid \TB M \) \> (コードの生成) \\
            \> \( \mid \TBL M \) \> (コードの埋め込み) \\
            \> \( \mid \verb|run|\ M \) \> (コードの実行) \\
            \> \( \mid \% M \) \> (ステージを跨ぐ \\
            \> \> \ コードの埋め込み (CSP)) \\
            \> \( \mid x \mid \lambda x:\tau.M \mid M\ M \)
        \end{tabbing}
    \end{block}
    * 説明の為に単純化しています
\end{frame}

\begin{frame}[fragile]{ステージを跨ぐコードの埋め込み(CSP)}
    任意の項をコードの中に埋め込むことを可能にする \\[3mm]

    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
  $\lambda$x:int.($\TB$(x + 1))
        \end{Verbatim}
    \end{exampleblock}
    吹き出し「xはコードでない通常の項」 \\
    吹き出し「ここはコードの中」
\end{frame}

\begin{frame}[fragile]{\LMD の型}
    \begin{block}{型}
        \begin{tabbing}
            \hspace{5mm} \( \tau \) \= ::= X \hspace{20mm} \= (型レベル定数) \\
            \> \( \mid \TW\ \tau \) \> (コード型) \\
            \> \( \mid x:\tau \to \tau \) \> (依存関数型) \\
            \> \( \mid \tau\ M \) \> (型の項への適用)
        \end{tabbing}
    \end{block}
\end{frame}

\begin{frame}[fragile]{\LMD の型の例}
    依存関数型の例
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
  double: n:int -> vec n -> vec n
        \end{Verbatim}
    \end{exampleblock}
    型の項への適用の例
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
  double 3: vec 3 -> vec 3
        \end{Verbatim}
    \end{exampleblock}
    コード型の例
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
  $\TB$(double 3): $\TW$(vec 3 -> vec 3)
        \end{Verbatim}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\LMD におけるvadd-gen}
    ベクトルの長さ(\verb|n|)を受け取って、\\その長さのベクトルを足し合わせる関数を作る関数
    \begin{exampleblock}{}
        \hspace{5mm} \verb|let rec vadd-gen = |$\lambda$\verb|n:int.| \\
        \hspace{10mm} $\TB$ \verb|(| $\lambda$\verb|v1:(vec |\onslide<2->{\%}\verb|n).|$\lambda$\verb|v2:(vec |\onslide<2->{\%}\verb|n).| ... \verb|)|
    \end{exampleblock}
    \onslide<2->{
        \begin{alertblock}{注意}
            \begin{center}
                長さnはコード($\TB$)の外で定義されているので、\\
            コードの中で使うにはCSP(\%)が必要
            \end{center}
        \end{alertblock}
    }
\end{frame}

\begin{frame}[fragile]{vadd-genとvadd-genで生成した関数の型}
    \newcommand{\Vn}{\text{vec}\ \%n}
    \newcommand{\Vt}{\text{vec}\ \%3}
    \begin{exampleblock}{}
        \hspace{5mm} \verb|val vadd-gen : n:int -> | \\
        \hspace{20mm} ($\TW$(\verb|vec %n -> vec %n -> vec %n|)) \\[2mm]
        \hspace{5mm} \verb|let vadd3 = vadd-gen 3;;| \\
        \hspace{5mm} \verb|val vadd3: |$\TW$\verb|(vec %3 -> vec %3 -> vec %3)|
    % \begin{tabbing}
    %     \> \( \textbf{let}\ \text{vadd3} = \text{vadd-gen}\ 3;; \) \\
    %     \> \( \text{val}\ \text{vadd3} : \TW (\Vt \to \Vt \to \Vt) \) \\[2mm]
    % \end{tabbing}
    \end{exampleblock}
    生成した関数(vadd3)が長さ3のベクトルだけを\\受け取ることが型の中に現れている
\end{frame}

\begin{frame}[fragile]{vadd3の技術的な問題}
    他の関数と組み合わせるのが難しい
    \newcommand{\Vn}{\text{vec}\ \%n}
    \newcommand{\Vpt}{\text{vec}\ \%3}
    \newcommand{\Vt}{\text{vec}\ 3}
    \begin{exampleblock}{}
    \begin{tabbing}
        \hspace{5mm} \= \( \text{val}\ \text{vadd3} : \TW (\Vpt \to \Vpt \to \Vpt) \) \\
        \> \( \text{val}\ \text{double} : \TW (\Vt \to \Vt) \) \\[2mm]
        \> \( \textbf{let}\ \text{add-double}\ v\ w = \) \\
        \> \hspace{5mm} \( \TB (\underbrace{\TBL\text{double}}_{\Vt \to \Vt}\ \underbrace{(\TBL \text{vadd3}\ \TBL v\ \TBL w)}_{\Vpt});; \) \\
    \end{tabbing}
    \end{exampleblock}
    型が合わないので組み合わせることができない
\end{frame}

\begin{frame}[fragile]{解決}
    \newcommand{\Vt}{\text{vec}\ 3}
    \newcommand{\Vpt}{\text{vec}\ \%3}
    \( M \) が閉じた項の場合に限りCSP(\%)を消すことを許す (\QPercent)
    {\footnotesize{
    \begin{center}
        \infrule[{\QPercent}]{
            M \text{ is a closed term.}
        }{
            \G\vdash \% M \E M
        } \\[2mm]
        \infrule[{\TConv}]{
            \G\V M:\tau@n \andalso
            \G\V \tau\equiv \sigma @n
        }{
            \G\V M:\sigma@n
        }
    \end{center}
    }}
    \begin{exampleblock}{}
        \begin{itemize}
            \item \( \text{vec}\ \%3 \E \text{vec}\ 3 \)
            \item \( \text{vadd3} : \TW (\Vt \to \Vt \to \Vt) \) \\
                \hspace{15mm} \( (\E  \TW (\Vpt \to \Vpt \to \Vpt)) \)
        \end{itemize}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{型安全性}
\end{frame}

\begin{frame}[fragile]{型推論アルゴリズム}
\end{frame}

\begin{frame}[fragile]{関連研究}
    \begin{itemize}
        \item \LTP [Hanada\&Igarashi'14]
        \item Concoqtion [Forgarty et al.'07]
            \begin{itemize}
                \item MetaOCamlに制限された形の依存型を導入
            \end{itemize}
        \item \( \lambda_{H\circ} \) [Pasalic'04]
            \begin{itemize}
                \item 依存型付きメタプログラミング言語
                \item コードの評価とCSPがない
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{結論}
    多段階計算に依存型を導入した
    \begin{itemize}
        \item 依存型で、生成されたコードの不正な使用を防止
        \item 型安全性を証明 
        \item 型推論のアルゴリズムを設計 
    \end{itemize}
\end{frame}

% \begin{frame}[fragile]{\LTP の型}
%     \begin{block}{型}
%         \begin{tabbing}
%             \hspace{5mm} \( \tau \) \= ::= X \hspace{20mm} \= (intなどの型レベル定数) \\
%             \> \( \mid \TW\ \tau \) \> (コード型) \\
%             \> \( \mid \tau \to \tau \) \> (関数型)
%         \end{tabbing}
%     \end{block}
%
%     \begin{block}{型付け判断}
%         \begin{center}
%             \( \G \V M : \tau @ n \)
%         \end{center}
%         * 「型環境\( \G \)の下で項\( M \)に型\( \tau \)がステージ\( n \)でつく」\\
%         ** \( n \) はステージ.
%     \end{block}
% \end{frame}
%
% \begin{frame}[fragile]{ステージとは何か?}
%     項の外側にある \( \TB \) の数
%     \begin{exampleblock}{}
%         \begin{center}
%             \( \underbrace{\TB\ \overbrace{(\lambda x:\text{int}.x + 1)}^{\let\scriptstyle\textstyle\substack{\text{stage }1}}}_{\let\scriptstyle\textstyle\substack{\text{stage }0}} \)
%         \end{center}
%     \end{exampleblock}
%
%     \LTP の型判断と型環境はステージを含む
%     \begin{center}
%         \( x:\text{int}@1 \vdash x + 1 : \text{int} {\mathbf{@ 1}} \)
%     \end{center}
% \end{frame}
%
% \begin{frame}[fragile]{\LTP の型付け規則}
%     項を異なるステージの関数に適用できない
%     \begin{center}
%         {\footnotesize \infrule[\TApp]{
%             \G\V M:\sigma \to \tau @ n \andalso
%             \G\V N:\sigma @ n
%         }{
%             \G\V M\ N : \tau @ n
%         }}
%     \end{center}
%     \( \TB \)はステージを増加、\( \TBL \)はステージを減少させる
%     \begin{center}
%         {\footnotesize \infrule[{\TTB}]{
%             \G\V M:\tau @ n+1
%         }{
%             \G\V\TB M:\TW \tau @ n
%         } \hfil
%         \infrule[{\TTBL}]{
%             \G\V M:\TW \tau @ n
%         }{
%             \G\V\TBL M:\tau @ n + 1
%         }}
%     \end{center}
%     一般には異なるステージの項を使うことはできない
% \end{frame}
%
% \section{\LMD: \LTP の依存型による拡張}
%
% \begin{frame}{目次}
%     \tableofcontents[currentsection]
% \end{frame}
%
% \begin{frame}[fragile]{\LMD の概観}
%     \LTP の依存型による拡張
%     \begin{itemize}
%         \item \LMD の項は\LTP と同じ
%         \item 型は依存型で拡張されている
%         \item 型の間の同値関係を定義する規則がある
%     \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]{\LMD の型とカインド}
%     \LTP の型 + 依存型
%     \begin{block}{型}
%         \begin{tabbing}
%             \hspace{5mm} \( \tau \) \= ::= X \hspace{20mm} \= (型レベル定数) \\
%             \> \( \mid \TW\ \tau \) \> (コード型) \\
%             \> \( \bm{\mid \Pi x:\tau.\tau} \) \> (依存関数型) \\
%             \> \( \bm{\mid \tau\ M} \) \> (依存関数型への適用, e.g. \(\text{vec}\ 3\))
%         \end{tabbing}
%     \end{block}
%     \begin{block}{カインド(型の型)}
%         \( K ::= * \mid \Pi x:\tau.K \)
%     \end{block}
% \end{frame}
%
% \begin{frame}[fragile]{\LMD のカインド付け規則}
%     型は項を含みうるため、カインド付け判断もステージを含む
%     \begin{center}
%         \( \G \vdash \tau :: K @ n \)
%     \end{center}
%     \begin{center}
%         {\footnotesize
%         \infrule[{\KApp}]{
%             \G\V \sigma:: (\Pi x:\tau.K) @ n \andalso \G\V M:\tau @ n
%         }{
%             \G\V \sigma\ M::K[x\mapsto M] @ n
%         } \\[2mm]
%         \infrule[{\KAbs}]{
%             \G\V \tau :: * @ n \andalso \G,x:\tau@ n \V \sigma::*@n
%         }{
%             \G\V(\Pi x:\tau.\sigma) :: * @ n
%         }}
%     \end{center}
% \end{frame}
%
% \begin{frame}[fragile]{型の中のCSP}
%     コード型 \( \TW \) の中ではステージが1つ増える
%     \begin{center}
%         \infrule[{\KTW}]{
%             \G\V \tau::*@ n + 1
%         }{
%             \G\V\TW \tau::*@ n
%         }
%     \end{center}
%     このためコード型の外の変数\( n \)を\( \TW \)の中で使うためにはCSPが必要である
%     \begin{exampleblock}{}
%         \begin{tabbing}
%             \hspace{5mm} \= \text{val zeros} : \( \Pi n:\text{int}.(\text{vec}\ n) \) \\
%             \> \( \lambda n:\text{int}. (\TB (\% \text{zeros}\ \% n)): \underbrace{\Pi n:\text{int}. \TW (\overbrace{\text{vec}\ \%n}^{\text{stage }1})}_{\text{stage }0} \)
%         \end{tabbing}
%     \end{exampleblock}
% \end{frame}
%
% \begin{frame}[fragile]{\LMD の定数と型レベル定数}
%     \begin{itemize}
%         \item 定数: \( 0,1,2,3,\dots \)
%         \item 型レベル定数: int, vec, \dots
%     \end{itemize}
%     はどのステージでも使える
%     \begin{exampleblock}{}
%         \begin{tabbing}
%             \hspace{5mm} \= \text{val double-at-0} : \( \text{vec }3 \to \text{vec }3 \) \\[2mm]
%             \> \textbf{let } \text{double} = \( \TB (\%\ \text{double-at-0}) \) \\
%             \> \text{val double} : \( \TW \underbrace{(\text{vec }3 \to \text{vec }3)}_{\text{stage 1}} \)
%         \end{tabbing}
%     \end{exampleblock}
% \end{frame}
%
% \begin{frame}[fragile]{vadd3の技術的な問題}
%     他の関数と組み合わせるのが難しい
%     \newcommand{\Vn}{\text{vec}\ \%n}
%     \newcommand{\Vpt}{\text{vec}\ \%3}
%     \newcommand{\Vt}{\text{vec}\ 3}
%     \begin{exampleblock}{}
%     \begin{tabbing}
%         \hspace{5mm} \= \( \text{val}\ \text{vadd3} : \TW (\Vpt \to \Vpt \to \Vpt) \) \\
%         \> \( \text{val}\ \text{double} : \TW (\Vt \to \Vt) \) \\[2mm]
%         \> \( \textbf{let}\ \text{add-double}\ v\ w = \) \\
%         \> \hspace{5mm} \( \TB (\underbrace{\TBL\text{double}}_{\Vt \to \Vt}\ \underbrace{(\TBL \text{vadd3}\ \TBL v\ \TBL w)}_{\Vpt});; \) \\
%     \end{tabbing}
%     \end{exampleblock}
%     型が合わないので組み合わせることができない
% \end{frame}
%
% \begin{frame}[fragile]{解決}
%     \newcommand{\Vt}{\text{vec}\ 3}
%     \newcommand{\Vpt}{\text{vec}\ \%3}
%     \( M \) が閉じた項の場合に限りCSP(\%)を消すことを許す (\QPercent)
%     {\footnotesize{
%     \begin{center}
%         \infrule[{\QPercent}]{
%             M \text{ is a closed term.}
%         }{
%             \G\vdash \% M \E M
%         } \\[2mm]
%         \infrule[{\TConv}]{
%             \G\V M:\tau@n \andalso
%             \G\V \tau\equiv \sigma @n
%         }{
%             \G\V M:\sigma@n
%         }
%     \end{center}
%     }}
%     \begin{exampleblock}{}
%         \begin{itemize}
%             \item \( \text{vec}\ \%3 \E \text{vec}\ 3 \)
%             \item \( \text{vadd3} : \TW (\Vt \to \Vt \to \Vt) \) \\
%                 \hspace{15mm} \( (\E  \TW (\Vpt \to \Vpt \to \Vpt)) \)
%         \end{itemize}
%     \end{exampleblock}
% \end{frame}
%
% \begin{frame}[fragile]{性質}
%     以下の性質を証明した
%     \begin{itemize}
%         \item 代入補題
%         \item 強正規化性
%         \item 合流性
%         \item 進行性
%     \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]{関連研究}
%     \begin{itemize}
%         \item \LTP [Hanada\&Igarashi'14]
%         \item Concoqtion [Forgarty et al.'07]
%             \begin{itemize}
%                 \item MetaOCamlに制限された形の依存型を導入
%             \end{itemize}
%         \item \( \lambda_{H\circ} \) [Pasalic'04]
%             \begin{itemize}
%                 \item 依存型付きメタプログラミング言語
%                 \item コードの評価とCSPがない
%             \end{itemize}
%     \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]{結論}
%     多段階計算に依存型を導入した
%     \begin{itemize}
%         \item 依存型で生成されたコードの不正な仕様を防止
%             \begin{itemize}
%                 \item 制限されていない依存型
%             \end{itemize}
%         \item 同値関係を定義
%             \begin{itemize}
%                 \item 特にCSPについて
%             \end{itemize}
%         \item 型推論のアルゴリズムを設計 
%         \item 型健全性を証明 
%     \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]{Why a Stage is Needed?}
%     Without stage, \textbf{run} may causes a run-time error.
%     \begin{exampleblock}{}
%         \begin{center}
%     \( \TB (\lambda x:\tau. \TBL (\textbf{run}\ \TB x)) \)
%         \end{center}
%     \end{exampleblock}
%
%     With stage, the same code cannot be typed.\\
%     Because the subterm \( (\Lambda\alpha.\ \TB_\alpha x) \) is ill-typed.
%     \begin{exampleblock}{}
%         \begin{center}
%     \( \TB_\alpha (\lambda x:\tau. \TBL_\alpha ((\Lambda\alpha.\ \TB_\alpha x)\ \varepsilon)) \)
%         \end{center}
%     \end{exampleblock}
% \end{frame}

% \begin{frame}[fragile]{Styles of Multi-stage Programming}
%     \begin{itemize}
%         \item Strings
%             \begin{itemize}
%                     \item Ruby, Perl, etc.
%             \end{itemize}
%         \item ASTs
%             \begin{itemize}
%                     \item Lisp
%             \end{itemize}
%         \item ASTs and code types
%             \begin{itemize}
%                     \item MetaOCaml
%             \end{itemize}
%     \end{itemize}
%     \note{
%         There are three kinds of multi-stage Programming.
%     }
% \end{frame}

% \begin{frame}[fragile]{Generated functions by vadd-gen in \LMD}
%     Type system prevents illegal use of generated function.
%     \renewcommand{\V}{\text{vec}}
%     \begin{tabbing}
%         \( \text{vadd3}\ [1;2;3]\ [4;5;6];; \) \\
%         \( - : \V = [5;7;9] \) \\[2mm]
%         \( \text{vadd3}\ [1;2;3;4]\ [4;5;6;7];; \) \\
%         \( \longrightarrow \textbf{TYPE ERROR!} \text{ (not RUNTIME ERROR)} \)
%     \end{tabbing}
%     \note{
%         Type of generated functions by vadd-gen in \LMD have the length information in their types.
%     }
% \end{frame}

% \begin{frame}[fragile]{Terms of \LMD}
%     \begin{block}{Terms}
%         \( M ::= c \mid x \mid \lambda x:\tau.M\ \mid M\ M \mid \TB_\alpha M \mid \textbf{run}\ M \mid \TBL_\alpha M \)
%     \end{block}
%     \begin{itemize}
%         \item \( c \): constants
%             \begin{itemize}
%                     \item true, false, etc.
%             \end{itemize}
%         \item \( \TB_\alpha M \): code value
%         \item \( \textbf{run}\ M \): run a code value \( M \)
%             \begin{itemize}
%                 \item \( \textbf{run }(\text{vadd-gen }3)\)
%             \end{itemize}
%     \end{itemize}
%     \note{
%         Then, let me explain details of \LMD. \\
%         \( \TBL_\alpha M \) is not needed?
%     }
% \end{frame}

% \begin{frame}[fragile]{Types of \LMD}
%     \begin{block}{Types}
%     \( \tau,\sigma ::= X \mid \Pi x:\tau.\sigma \mid \tau\ M \mid \TW_{\alpha} \tau \mid \F\alpha.\tau \)
%     \end{block}
%     \begin{itemize}
%         \item \( X \): type-level constants 
%             \begin{itemize}
%                 \item \( \text{vec} \), \( \text{int} \).
%             \end{itemize}
%         \item \( \Pi x:\tau.\sigma \): dependent type.
%         \item \( \tau\ M \): Application of term to dependent type.
%             \begin{itemize}
%                 \item \( \text{vec } 3 \)
%             \end{itemize}
%         \item \( \TW_{\alpha} \tau \): a type of code of type \( \tau \).
%             \begin{itemize}
%                 \item \( \text{vadd-gen 3} : \TW_\alpha (\text{vec}\ 3 \to \text{vec}\ 3 \to \text{vec}\ 3) \)
%             \end{itemize}
%     \end{itemize}
%     \note{
%     }
% \end{frame}

% \begin{frame}[fragile]{Kinds of \LMD}
%     \begin{block}{Kinds}
%         \( K ::= * \mid \Pi x:\tau.K \)
%     \end{block}
%     \begin{itemize}
%         \item \( * \): kind of proper type
%             \begin{itemize}
%                 \item \( \text{int} :: * \)
%             \end{itemize}
%         \item \( \Pi x:\tau.K \): kind dependent on term.
%             \begin{itemize}
%                 \item \( \text{vec} :: (\Pi x:\text{int}.*) \)
%             \end{itemize}
%     \end{itemize}
%     \note{
%     }
% \end{frame}

% \begin{frame}[fragile]{Judgements of \LMD}
%     \begin{itemize}
%         \item \( \G \V K @ A \)
%             \begin{itemize}
%                 \item \( K \) is a proper kind under signature \( \Sigma \) at stage \( A \).
%             \end{itemize}
%         \item \( \G \V \tau :: K @ A \)
%             \begin{itemize}
%                 \item Type \( \tau \) has kind \( K \) under signature \( \Sigma \) at stage \( A \).
%             \end{itemize}
%         \item \( \G \V M : \tau @ A \)
%         \item \( \G \V K \E K' @ A \)
%             \begin{itemize}
%                 \item Kind \( K \) is equivalent to \( K' \) under signature \( \Sigma \) at stage \( A \).
%             \end{itemize}
%         \item \( \G \V \tau \E \tau' @ A \)
%         \item \( \G \V M \E M' @ A \)
%     \end{itemize}
%     \note{
%     }
% \end{frame}

% \begin{frame}[fragile]{What is stage\ \( A \)\ ?}
%     % I copied this underwrite macro from
%     % https://tex.stackexchange.com/questions/141932/how-to-write-under-an-underline.
%     % \underwrite[<thickness>]{<numerator>}{<denominator>}
%     \newcommand{\underwrite}[3][]{
%         \genfrac{}{}{#1}{}{\textstyle #2}{\textstyle #3}
%     }
%
%     Level of nested brankets
%     \begin{block}{Stages}
%         \( A := \varepsilon (\text{empty}) \mid \alpha \mid A\alpha \)
%     \end{block}
%     \begin{center}
%         \( \underbrace{(\textbf{run}\ (\TB_\alpha\ \overbrace{(2 + 3)}^{\let\scriptstyle\textstyle\substack{@\alpha}})) + 1}_{\let\scriptstyle\textstyle\substack{@\varepsilon}} \)
%     \end{center}
%     \note{
%         Stage is a sequence of stage variables which appended to each brack triangles.
%         \( \varepsilon \) means the empty sequence
%
%         The wholes expression is a term on stage \( \varepsilon \),
%         But subexpression in the brack triangle is a term on stage \( \alpha \).
%     }
% \end{frame}

% \begin{frame}[fragile]{What is signature \( \Sigma \)\ ?}
%     Signature \( \Sigma \) is a sequence of type-level constants and constant values.
%     \begin{itemize}
%         \item For example,
%             \begin{itemize}
%                 \item \( \Sigma = \text{int}::*, \text{vec}::\Pi x:\text{int}.*, 0:\text{int} \)
%             \end{itemize}
%         \item Elements of \( \Sigma \) can be used at any stages.
%     \end{itemize}
%     \note{
%         自然数が無限個あるというツッコミを誘発する気がする。
%         後者関数が存在することにするか?
%     }
% \end{frame}

% \begin{frame}[fragile]{Typing Rules of \LMD}
%     \begin{center}
%         \infrule[{\TTB}]{
%             \G\V M:\tau@{A\alpha}
%         }{
%             \G\V\TB_{\alpha}M:\TW_{\alpha}\tau@A
%         } \\[2mm]
%         \infrule[{\textsc{T-App}}]{
%             \G\V M:(\Pi (x:\sigma).\tau)@A \andalso
%             \G\V N:\sigma@A
%         }{
%             \G\V M\ N : \tau[x\mapsto N]@A
%         } \\[2mm]
%         \infrule[{\TConst}]{
%             c:\tau \in \Sigma \andalso
%         }{
%             \G \V c:\tau@A
%         }
%     \end{center}
%     \begin{itemize}
%         \item Terms are stage sensitive so cannot ignore stages.
%         \item Constants in \( \Sigma \) can be used at any stages.
%     \end{itemize}
%     \note{
%         Let's have a look on some typing rules.
%     }
% \end{frame}

% \begin{frame}[fragile]{Kinding Rules of \LMD}
%     \begin{center}
%         \infrule[{\KTW}]{
%             \G\V \tau::*@A\alpha
%         }{
%             \G\V\TW_\alpha \tau::*@A
%         }\\[2mm]
%         \infrule[{\KApp}]{
%             \G\V \sigma:: (\Pi x:\tau.K)@A \andalso \G\V M:\tau@A
%         }{
%             \G\V \sigma\ M::K[x\mapsto M]@A
%         }
%         \infrule[{\KTConst}]{
%             X::K \in \Sigma
%         }{
%             \G \V X::K@A
%         }
%     \end{center}
%     \begin{itemize}
%         \item Types are also stage sensitive.
%         \item Type-level constants in \( \Sigma \) can be used at any stages.
%     \end{itemize}
%     \note{
%         Kinding rules have something in common with typing rules.
%     }
% \end{frame}

% \begin{frame}[fragile]{Example of Kinding Derivation}
%     \renewcommand{\vec}{\text{vec}}
%     \( \V \TB_\alpha [1,2,3] : \underbrace{\TW_\alpha (\vec\ 3)}_{\TW_\alpha (\vec\ 3) :: * @ \varepsilon} @ \varepsilon \) \\[2mm]
%     \pause
%     \( \Sigma = \vec::\Pi x:\text{int}.*, 0:\text{int}, 1:\text{int}, \cdots \)
%     \begin{center}
%         \footnotesize
%         \begin{minipage}{0.7\hsize}
%             \infer[\KTW]
%             {\V \TW_\alpha (\vec\ 3) :: * @ \varepsilon}
%             {
%                 \infer[\KApp]
%                 {\V \vec\ 3 :: * @ \alpha}
%                 {
%                     \infer[\KTConst]
%                     {\V \vec :: \Pi x:\text{int}.* @ \alpha}
%                     {\vec :: \Pi x:\text{int}.* \in \Sigma}
%                     \andalso
%                     \infer[\TConst]
%                     {\V 3 : \text{int} @ \alpha}
%                     {3 : \text{int} \in \Sigma}
%                 }
%             }
%         \end{minipage}
%     \end{center}
%     We can use \vec\ and integers at any stages.
%     \note{
%         The constructed type vec 3 is stage sensitive so we cannot use at arbitrary stages
%         but the elements, vec and 3 are in the signature \( \Sigma \) and can be used at any stages.
%     }
% \end{frame}

% \begin{frame}[fragile]{Type and Term Equality Rules of \LMD}
%     \begin{center}
%         \footnotesize{
%             \infrule[{\QTApp}]{
%                 \G\V \tau \E \sigma :: (\Pi x:\rho.K)@A \andalso
%                 \G\V M \E N : \rho @A
%             }{
%                 \G\V \tau\ M \E \sigma\ N :: K[x \mapsto M]@A
%             } \\[2mm]
%             \infrule[{\QBeta}]{
%                 \G,x:\sigma@A\V M:\tau@A \andalso
%                 \G\V N:\sigma@A
%             }{
%                 \G\V(\lambda x:\sigma.M)\ N\E M[x\mapsto N] : \tau[x \mapsto N]@A
%             } \\[2mm]
%             \infrule[{\QPercent}]{
%                 \G\V M:\tau@{A\alpha} \andalso
%                 \G\V M:\tau@A
%             }{
%                 \G\V\%_\alpha M \E M : \tau@{A\alpha}
%             } \\[2mm]
%             \infrule[{\textsc{T-Conv}}]{
%                 \G\V M:\tau@A \andalso
%                 \G\V \tau\equiv \sigma :: K@A
%             }{
%                 \G\V M:\sigma@A
%             }
%         }
%     \end{center}
%     \note{
%     }
% \end{frame}

% \begin{frame}[fragile]{Examples of Type Equality}
%     \renewcommand{\V}{\text{vec}}
%     \begin{itemize}
%         \item \( (\lambda x:\text{int}.x)\ 3\E 3 \)
%             \begin{itemize}
%                 \item From \QBeta.
%             \end{itemize}
%         \item \( \V\ ((\lambda x:\text{int}.x)\ 3) \E \V\ 3 \)
%             \begin{itemize}
%                 \item From \QTApp and \QBeta.
%             \end{itemize}
%         \item \( \V\ (\%_\alpha 3) \E \V\ 3 \)
%             \begin{itemize}
%                 \item Because \( 3 \) has type \text{int} at any stage, we can use \QPercent.
%             \end{itemize}
%     \end{itemize}
%     \note{
%         Shold I show complete derivation tree?
%     }
% \end{frame}

\end{document}
