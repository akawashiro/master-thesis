\documentclass[dvipdfmx,aspectratio=169, 20pt]{beamer}
\usepackage[absolute,overlay]{textpos}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{ascmac}
\usepackage[backend=biber, style=numeric]{biblatex}
\usepackage{color}
\usepackage{mathtools}
\usepackage{url}
\usepackage{bcprules, proof}
\usepackage{xparse}
\usepackage{xspace}
\usepackage{fancybox}
\usepackage{fancyvrb}
\usepackage{float}
\usepackage{bcprules}
\usepackage{ebproof}
\usepackage{lscape}
\usepackage{pgfpages}
\usepackage{bm}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\usetikzlibrary{shapes.callouts}

% beamer cheat sheet
% http://www.cpt.univ-mrs.fr/~masson/latex/Beamer-appearance-cheat-sheet.pdf

% Make Japanese font gothic
\renewcommand{\kanjifamilydefault}{\gtdefault}

\uselanguage{japanese}
\languagepath{japanese}
\deftranslation[to=japanese]{Theorem}{定理}
\deftranslation[to=japanese]{theorem}{定理}

% Make note pages suer simple.
% \setbeamertemplate{note page}[plain]

% This option generate pdf files showing notes on the right hand side of each
% pages. But this optionn has some bugs. I recommend you not to use this
% option.
% \setbeameroption{show notes on second screen=right}

% Note options
% Show plain text in note pages.
\setbeamertemplate{note page}[plain]
% Show / hide note
% \setbeameroption{show notes}
% \setbeameroption{hide notes}
% \setbeameroption{show only notes}

% Show grid for debug
% \setbeamertemplate{background}[grid][step=1cm]

% Use default design theme. I quit to use this theme because it has no boxed
% environments.
% \usetheme{default}
\usetheme{Boadilla}

% Add page numbers to footnotes. This line does not work for Boadilla theme.
% \setbeamertemplate{footline}[frame number]

% So, I use some hack in
% https://tex.stackexchange.com/questions/66995/modify-footer-of-slides.
% \makeatother and \makeatletter enable us to change internal package things.
\makeatother
\setbeamertemplate{footline}
{
    \leavevmode
    \hbox{
        \setbeamercolor{coloredboxstuff}{fg=black,bg=white}
        \hskip0.85\paperwidth
        \begin{beamercolorbox}[wd=0.10\paperwidth,ht=2.25ex,dp=1ex,right]{coloredboxstuff}
            {\textbf{\insertframenumber{} / \inserttotalframenumber}}
        \end{beamercolorbox}}
    \vskip0pt
}
\makeatletter

% Remove all navigation symbols
\setbeamertemplate{navigation symbols}{}
% using non standard fonts for beamer
\usefonttheme{professionalfonts}
% Set the font size of titles
% See other font category at
% https://tex.stackexchange.com/questions/183052/what-are-all-the-possible-first-arguments-to-setbeamerfont
\setbeamerfont{title}{size=\normalsize}
\setbeamerfont{frametitle}{size=\normalsize}
\setbeamerfont{normal text}{size=\small}
\setbeamerfont{itemize/enumerate body}{size=\small}
\setbeamerfont{itemize/enumerate subbody}{size=\small}
\setbeamerfont{frametitle continuation}{size=\small}
\setbeamerfont{framesubtitle}{size=\small}
\setbeamerfont{abstract}{size=\small}
\setbeamerfont{projected text}{size=\small}
\setbeamerfont{block title}{size=\small}
\setbeamerfont{footline}{size=\tiny}
\setbeamerfont{note page}{size=\scriptsize}

% You need this line in order to enforce normal text font setting.
% https://tex.stackexchange.com/questions/320223/how-to-enforce-a-font-series-in-beamer-for-normal-default-text
\AtBeginDocument{\usebeamerfont{normal text}}

% Settings of Table of Contents page.
% Append underline to currentsection.
% https://tex.stackexchange.com/questions/280813/beamer-change-color-underline-but-do-not-hide-shade-other-section-in-table-of-c/283585
% https://tex.stackexchange.com/questions/414250/numbers-shading-and-alert-in-beamer-table-of-contents
% Page 101 of http://tug.ctan.org/macros/latex/contrib/beamer/doc/beameruserguide.pdf
\setbeamertemplate{section in toc}{
    \inserttocsectionnumber.\ \bf{\underline{\inserttocsection}}
}
\setbeamertemplate{subsection in toc}{
    \hspace{5mm} \inserttocsectionnumber.\inserttocsubsectionnumber.\  {\bf{\underline{\inserttocsubsection}}} \\[1mm]
}
\setbeamertemplate{section in toc shaded}{
    \inserttocsectionnumber.\  \inserttocsection
}
\setbeamertemplate{subsection in toc shaded}{
    \hspace{5mm} \inserttocsectionnumber.\inserttocsubsectionnumber.\  \inserttocsubsection \\[1mm]
}

\setbeamertemplate{bibliography item}{\insertbiblabel}
% \setbeamertemplate{blocks}[default]
\setbeamertemplate{blocks}[rounded]
\setbeamertemplate{theorems}[normal font]

% \bibliography{main}{}
\addbibresource{main.bib}
\DeclareSortingScheme{mysorting}{\sort{\citeorder}}
\ExecuteBibliographyOptions{sorting=mysorting}

\setlength\intextsep{0pt}
\setlength\textfloatsep{0pt}

\newcommand{\rulefbox}[1]{\fbox{\ensuremath{#1}} \hspace{1mm}}
\newcommand{\figheader}[2]{
  \begin{flushleft}
    #2 {\bf \normalsize #1}
\end{flushleft}}

\defbeamertemplate{description item}{align left}{\insertdescriptionitem\hfill}

% Load symbol macros
\input{symboldef.tex}

% I don't use sigma in this slides.
\renewcommand{\V}{\vdash}

\title{依存型付多段階計算体系}
\subtitle{A Dependently Typed Multi-stage Calculus}
\author{河田 旺}
\institute{五十嵐・末永研究室}
\date{2020年2月12日}

\begin{document}
\maketitle

% This blank page is for seeing notes easily.
% \begin{frame}{}
% \end{frame}

% Output the outline slide
% \begin{frame}{Contents}
%     \tableofcontents[currentsection]
%   \note{
%   }
% \end{frame}

\section{背景: 多段階計算とその問題点}

% \begin{frame}{目次}
%
%     \setbeamertemplate{section in toc}{
%         \inserttocsectionnumber.\ \inserttocsection
%     }
%
%     \tableofcontents
% \end{frame}

\begin{frame}{目次}
    \tableofcontents[currentsection]
\end{frame}

\begin{frame}[fragile]{多段階計算とはなにか}
    以下の2つを可能にするプログラミング手法
    \begin{itemize}
        \item 実行時のコード生成
        \item 生成したコードの実行
    \end{itemize}
    応用例
    \begin{itemize}
        \item 実行時の情報を使ったプログラムの高速化[Taha'07]
        \item 領域特化言語(DSL)の効率的な実装[Kiselyov'18]
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{MetaOCamlによる多段階計算の例1}
    \( \TB \) でコードの生成 ( \( \TW \)\ \verb|int| はint型のコードの型)
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 # let a = $\TB$ (1 + 2)
 val a : $\TW$ int = $\TB$ (1 + 2)
        \end{Verbatim}
    \end{exampleblock}
    \( \TBL \)で、生成したコードを他のコードに埋め込める
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 # let b = $\TB$ (($\TBL$ a) + ($\TBL$ a))
 val b : $\TW$ int = $\TB$ ((1 + 2) + (1 + 2))
        \end{Verbatim}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{MetaOCamlによる多段階計算の例2}
    \verb|run| でコードの実行
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 # run ($\TB$ (1 + 2))
 - : int = 3
 # run b
 - : int = 6
        \end{Verbatim}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{多段階計算の応用例: vadd-gen}
    ベクトルの長さを受け取って、\\その長さのベクトルを足し合わせる関数を作る関数
    \begin{exampleblock}{}
        \hspace{5mm} {\tt val vadd-gen : int -> $\TW$ (vec -> vec -> vec)} \\
        \hspace{5mm} {\tt \# let vadd3 = vadd-gen 3} \\
        \hspace{5mm} {\tt val vadd3 : $\TW$ (vec -> vec -> vec)} \\
        \hspace{20mm} {\tt = $\TB$ (fun v w -> } \\
        \hspace{25mm} \tikz[remember picture, baseline=(unrolled.base)]{\node (unrolled){\alt<2->{\underline{{\tt [v[0]+w[0];v[1]+w[1];v[2]+w[2]]}}}{{\tt [v[0]+w[0];v[1]+w[1];v[2]+w[2]] }}}}{\tt )}
    \end{exampleblock}
        \onslide<2->{
        \begin{tikzpicture}[remember picture, overlay]
            \node[rectangle callout, draw, callout absolute pointer={(unrolled.south)}, below=0.2cm of unrolled.south] {ループを使わないプログラム};
        \end{tikzpicture}}
\end{frame}

\begin{frame}[fragile]{vadd-genによって生成されたvadd3の問題点}
    誤った長さのベクトルを渡せてしまう
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 val vadd3 : $\TW$ (vec -> vec -> vec)
 # (run vadd3) [1;2;3] [4;5;6]
 - : vec = [5;7;9]
 # (run vadd3) [1;2] [4;5]
 ---> 実行時エラー発生
    \end{Verbatim}
    \end{exampleblock}
\end{frame}

\section{問題解決のためのアイデア}

\begin{frame}{目次}
    \tableofcontents[currentsection]
\end{frame}

\begin{frame}[fragile]{アイデア: 依存型の導入}
    \renewcommand{\V}{\text{vec}\ }
    依存型とは
    \begin{itemize}
        \item 項がパラメータとしてついている型
        \item ベクトルの長さが表現できる
    \end{itemize}
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
 [1;2]: vec 2
 vadd3 : $\TW$ (vec 3 -> vec 3 -> vec 3)

 # (run vadd3) [1;2] [4;5]
 ---> 実行する前に型で誤りを検知
 \end{Verbatim}
    \end{exampleblock}
    % 吹き出し「\verb|vec 2| \( \neq \) \verb|vec 3|」
\end{frame}

% \begin{frame}[fragile]{依存型[Martin-L{\"o}f'73]とは}
%     \renewcommand{\V}{\text{vec}\ }
%     依存型とは項をパラメータとして渡せる型
%     \begin{exampleblock}{ベクトルの長さを表現できる}
%         \begin{Verbatim}
%  [1;2;3]: vec 3
%         \end{Verbatim}
%     \end{exampleblock}
%     \begin{exampleblock}{パラメータは数字とは限らない任意の項}
%         \begin{Verbatim}
%  [1;2;3]: vec (1+2) 
%         \end{Verbatim}
%     \end{exampleblock}
% \end{frame}
%
% \begin{frame}[fragile]{依存型における型の同値関係}
%     見た目だけでは同値関係が判定できない
%     \begin{itemize}
%         \item \verb|vec 3|と\verb|vec (1+2)|は同値であって欲しい
%     \end{itemize}
%     型の間の同値関係(\( \tau \E \tau'\))を定める規則がある\\
%     \begin{itemize}
%     \item 例: 項 \(M \) と\(M'\)が同値なら型\( \tau\ M \)と\( \tau\ M'\)も同値 \\[2mm]
%     \hspace{15mm} {\small \infrule
%     { M \E M' }
%     { \tau\ M \E \tau\ M'}}
% \item \verb|3| \( \E \) \verb|1+2| なので \verb|vec 3| \( \E \) \verb|vec (1+2)|になる
%     \end{itemize}
%  %    \begin{exampleblock}{}
%  %        \begin{Verbatim}
%  % append: vec n -> vec m -> vec (n + m)
%  % append [1;2] [3;4;5]: vec 5 
%  %        \end{Verbatim}
%  %    \end{exampleblock}
% \end{frame}

\section{本研究について}

\subsection{依存型付多段階計算体系 \LMD}

\begin{frame}{目次}
    \tableofcontents[currentsection, currentsubsection]
\end{frame}

\begin{frame}[fragile]{本研究の貢献: \LMD}
    既存の多段階計算体系 \LTP [Hanada\&Igarashi'14] を\\
    拡張して依存型付多段階計算体系 \LMD を設計した
    \begin{itemize}
        \item 多段階計算の機能
        \item 依存型の機能
    \end{itemize}
    技術的な貢献
    \begin{itemize}
        \item \LMD の形式化
        \item 型安全性の証明
        \item 型推論アルゴリズムの設計と正当性の証明
    \end{itemize}
\end{frame}

% \section{既存の多段階計算体系 \LTP}

% \begin{frame}{目次}
%     \tableofcontents[currentsection]
% \end{frame}

% \begin{frame}[fragile]{\LTP [Hanada\&Igarashi'14] の概観}
%     \begin{table}
%         \begin{tabular}{ c | c | c }
%             & \LTP & MetaOCaml \\[2mm]
%             \hline
%             コードの作成 & \( \textbf{let } a = \TB (1 + 2) \) & \verb| let a = <(1+2)> | \\[2mm]
%             コードの埋め込み & \( (\TB (\TBL a + \TBL a)) \) & \verb| <(~a)+(~a)> | \\[2mm]
%             コード型 & \( \TW\ \text{int} \) & \verb| int code |
%         \end{tabular}
%     \end{table}
% \end{frame}

% \begin{frame}[fragile]{\LTP とは}
%     \begin{itemize}
%         \item Hanada, Igarashi による多段階計算体系
%         \item 今回の研究の拡張元
%     \end{itemize}
% \end{frame}

\begin{frame}[fragile]{\LMD の項}
    \begin{block}{項}
        \begin{tabbing}
            \hspace{2mm} \( M \) \= \( ::= \) \hspace{50mm} \= \\
            \> \( c \mid x \mid \lambda x:\tau.M \mid M\ M \) \> (通常の$\lambda$計算の項) \\
            \> \( \mid \TB M \) \> (コードの生成) \\
            \> \( \mid \TBL M \) \> (コードの埋め込み) \\
            \> \( \mid \verb|run|\ M \) \> (コードの実行) \\
            \> \( \mid \% M \) \> (ステージを跨ぐ項の \\
            \> \> \ コードへの埋め込み (CSP))
        \end{tabbing}
    \end{block}
    * 説明の為に単純化しています
\end{frame}

\begin{frame}[fragile]{ステージとは何か?}
    項の外側にある \( \TB \) の数
    \begin{exampleblock}{}
        \begin{center}
            \( \underbrace{\lambda \texttt{x:int.(}\TB\overbrace{{\texttt{(}}\lambda \texttt{y:int.y+1))}}^{\let\scriptstyle\textstyle\substack{\text{stage }1}}}_{\let\scriptstyle\textstyle\substack{\text{stage }0}} \)
        \end{center}
    \end{exampleblock}
    項には型とステージがある
    \begin{itemize}
        \item {\tt x}は{\tt int}型のステージ0の変数
        \item {\tt y}は{\tt int}型のステージ1の変数
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{ステージの存在意義}
    簡約を正しい順序で行う
    \begin{exampleblock}{}
        \hspace{16mm} \tikz[remember picture, baseline=(runterm.base)]{\node (runterm){\( \underbrace{\texttt{run (}\TB\overbrace{\texttt{(1+2)}}^{\text{stage 1}}\texttt{)}}_{\text{stage 0}}\)}} \\[2mm]
        \hspace{5mm} \onslide<2->{\( \longrightarrow \texttt{1+2} \)} \\
        \hspace{5mm} \onslide<3->{\( \longrightarrow \texttt{3}} \)
    \end{exampleblock}
    \onslide<5->{
    \begin{alertblock}{原則として異なるステージの項は使えない}
        \xmark\ $\lambda$\texttt{x:int}.\texttt{(}$\TB$\texttt{(}$\lambda$\texttt{y:int.}{\tt x}\texttt{+1))}
    \end{alertblock}}
    
    \onslide<4->{
    \begin{tikzpicture}[remember picture, overlay]
        \node[rectangle callout, draw, callout absolute pointer={(runterm.east)}, right=of runterm, align=left] {
            誤った簡約順序\\
            \( \longrightarrow \texttt{run (}\TB\texttt{3)} \) \\
            \( \longrightarrow \texttt{3} \)
        };
    \end{tikzpicture}}
\end{frame}

\begin{frame}[fragile]{ステージを跨ぐ項のコードへの埋め込み(CSP)}
    簡約の順序を保ちつつ\\
    低いステージの項をより高いステージの中に\\
    埋め込むための機能 \\[3mm]

    \begin{exampleblock}{}
        \hspace{5mm} $\lambda$\tikz[remember picture, baseline=(stage0.base)]{\node (stage0){\alt<2->{\underline{\tt{x:int}}}{\tt{x:int}}};}{\tt{.(}}$\TB${\tt (}\tikz[remember picture, baseline=(stage1.base)]{\node (stage1){\alt<3->{\underline{$\lambda$\tt y:int.\%x+1}}{$\lambda$\tt y:int.\%x+1}};}{\tt ))}
        \onslide<2->{
        \begin{tikzpicture}[remember picture, overlay]
            \node[rectangle callout, draw, callout absolute pointer={(stage0.south)}] at (-7,-2.3) {xはステージ0の項};
        \end{tikzpicture}}
    \onslide<3->{
        \begin{tikzpicture}[remember picture, overlay]
            \node[rectangle callout, draw, callout absolute pointer={(stage1.south)}] at (-2,-1.2) {ここはステージ1なので\%が必要};
        \end{tikzpicture}}
    \end{exampleblock}
    \vspace{20mm}
\end{frame}

\begin{frame}[fragile]{\LMD の型}
    \begin{block}{型}
        \begin{tabbing}
            \hspace{5mm} \( \tau \) \= ::= X \hspace{20mm} \= (型レベル定数) \\
            \> \( \mid \TW\ \tau \) \> (コード型) \\
            \> \( \mid x:\tau \to \tau \) \> (依存関数型) \\
            \> \( \mid \tau\ M \) \> (型の項への適用)
        \end{tabbing}
    \end{block}
\end{frame}

\begin{frame}[fragile]{\LMD の型の例}
    依存関数型の例
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
  (* 長さnのベクトルの各要素を2倍する関数 *)
  val double: (n:int -> vec n -> vec n)
  # double 3
  - : vec 3 -> vec 3
        \end{Verbatim}
    \end{exampleblock}
    コード型の例
    \begin{exampleblock}{}
        \begin{Verbatim}[commandchars=\\\{\},codes={\catcode`$=3\catcode`^=7}]
  # let double-code = $\TB$(%(double 3))
  val double-code : $\TW$(vec 3 -> vec 3)
        \end{Verbatim}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{\LMD におけるvadd-gen}
    ベクトルの長さ(\verb|n|)を受け取って、\\その長さのベクトルを足し合わせる関数を作る関数
    \begin{exampleblock}{}
        \hspace{5mm} \verb|let rec vadd-gen = |$\lambda$\verb|n:int.| \\
        \hspace{10mm} $\TB$ \verb|(| $\lambda$\verb|v1:(vec |\onslide<2->{\underline{\%}}\verb|n).|$\lambda$\verb|v2:(vec |\onslide<2->{\underline{\%}}\verb|n).| ... \verb|)|
    \end{exampleblock}
    \onslide<2->{
        \begin{alertblock}{注意}
            \begin{center}
                長さnはステージ0で定義されているので、\\
                ステージ1($\TB$の中)で使うにはCSP(\%)が必要
            \end{center}
        \end{alertblock}
    }
\end{frame}

\begin{frame}[fragile]{vadd-genとvadd-genで生成した関数の型}
    \newcommand{\Vn}{\text{vec}\ \%n}
    \newcommand{\Vt}{\text{vec}\ \%3}
    \begin{exampleblock}{}
        \hspace{5mm} \verb|val vadd-gen : n:int -> | \\
        \hspace{20mm} ($\TW$(\verb|vec %n -> vec %n -> vec %n|)) \\[2mm]
        \hspace{5mm} (* $\TB$と同様に$\TW$の場合も\verb|%|が必要 *) \\[5mm]
        \hspace{5mm} \verb|let vadd3 = vadd-gen 3;;| \\
        \hspace{5mm} \verb|val vadd3: |$\TW$\verb|(vec %3 -> vec %3 -> vec %3)|
    % \begin{tabbing}
    %     \> \( \textbf{let}\ \text{vadd3} = \text{vadd-gen}\ 3;; \) \\
    %     \> \( \text{val}\ \text{vadd3} : \TW (\Vt \to \Vt \to \Vt) \) \\[2mm]
    % \end{tabbing}
    \end{exampleblock}
    生成した関数(vadd3)が長さ3のベクトルだけを\\受け取ることが型から判断できる
\end{frame}

\begin{frame}[fragile]{vadd3の技術的な問題}
    他の関数と組み合わせるのが難しい

    
    \newcommand{\Vn}{\text{vec}\ \%n}
    \newcommand{\Vpt}{\text{vec}\ \%3}
    \newcommand{\Vt}{\text{vec}\ 3}
    \begin{alertblock}{2つのベクトルを足し合わせて2倍する関数のコード}
        \hspace{5mm} \verb|val vadd3: |$\TW$\verb|(vec %3 -> vec %3 -> vec %3)| \\
        \hspace{5mm} \verb|val double-code : |$\TW$\verb|(vec 3 -> vec 3)| \\[3mm]
        \hspace{1mm}\onslide<2->{\xmark}\ \verb|let add-double =| $\TB$($\lambda$\verb|v:vec %3.|$\lambda$\verb|w:vec %3.| \\
        \hspace{1mm}\onslide<2->{\xmark}\hspace{10mm} \tikz[remember picture, baseline=(double.base)]{\node (double){\alt<3->{\underline{$\TBL${\tt double-code}}}{$\TBL${\tt double-code }}}}(\tikz[remember picture, baseline=(vadd3.base)]{\node (vadd3){\alt<4->{\underline{$\TBL${\tt vadd3 v w}}}{$\TBL${\tt vadd3 v w}}}}{\tt ))}
    \end{alertblock}
        \onslide<3->{
        \begin{tikzpicture}[remember picture, overlay]
            \node[rectangle callout, draw, callout absolute pointer={(double.south)}, below=0.2cm of double.south] {{\tt vec 3 -> vec 3}};
        \end{tikzpicture}}
    \onslide<4->{
        \begin{tikzpicture}[remember picture, overlay]
            \node[rectangle callout, draw, callout absolute pointer={(vadd3.south)}, below right=0.2cm and 0.2cm of vadd3.south] {{\tt vec \%3}};
        \end{tikzpicture}}
    \onslide<5->{\begin{alertblock}{}型が合わないので組み合わせることができない\end{alertblock}}
\end{frame}

\begin{frame}[fragile]{解決策}
    項\( M \) と 項\( \%M \)を以下の条件下で同一視する
    \begin{itemize}
        \item 条件: \( M \)が自由変数を含まない
    \end{itemize}
    \begin{exampleblock}{同一視される型の例}
        \begin{itemize}
            \item \verb|vec %3| と \verb|vec 3|
            \item \(\TW\)\verb|(vec 3 -> vec 3 -> vec 3)| \\
                と \(\TW\)\verb|(vec %3 -> vec %3 -> vec %3)|
        \end{itemize}
    \end{exampleblock}
    \onslide<2->{
        \begin{block}{}
            このような同一視をしても型安全性に\\影響がないことを示した
        \end{block}}
\end{frame}

\begin{frame}[fragile]{\LMD の形式化}
    \begin{itemize}
        \item 項\(M\), 型\(\tau\)
        \item 簡約関係\(M \longrightarrow M'\) \\[2mm]
            \hspace{5mm} {\footnotesize{\( (\lambda x:\tau.M) N \longrightarrow_\beta M[x \mapsto N] \)}} \\
            \hspace{5mm} {\footnotesize{\( \TBL_\alpha (\TB_\alpha M)\longrightarrow_\blacklozenge M \)}} \\
            \hspace{5mm} {\footnotesize{\( (\Lambda \alpha.M)\ A \longrightarrow_\Lambda M[\alpha \mapsto A] \)}}
        \item 型判断 \( \Gamma \vdash M : \tau @ A \)
            {\scriptsize
            \begin{center}
                \infrule[\TVar]{x:\tau @A \in \G}{\G \V x:\tau @A} \hfil
                \infrule[\TCsp]{
                    \G\V M:\tau@A \andalso \G\V \tau::*@{A\alpha}
                }{
                    \G\V \%_\alpha M:\tau@{A\alpha}
                }
            \end{center}
            }
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{\LMD の性質}
    \begin{theorem}[型安全性]
        項\(M\)に型\(\tau\)がつく(\(\Gamma \vdash M : \tau \))ならば\\
        \(M\)の簡約中に型エラーは起きない
    \end{theorem}
    \begin{theorem}[強正規化性]
        \(\Gamma \vdash M : \tau \)ならば\(M\)から始まる無限簡約列はない
    \end{theorem}
    \begin{theorem}[合流性]
        \(\Gamma \vdash M : \tau \)であり、\(M\)を簡約して2つの異なる項\(M'\)と\(M''\)を得たとき、適切に\(M'\)と\(M''\)を簡約すれば同一の項\(M'''\)を得る
    \end{theorem}
\end{frame}

\subsection{\LMD の型推論アルゴリズム}

\begin{frame}{目次}
    \tableofcontents[currentsection, currentsubsection]
\end{frame}

\begin{frame}[fragile]{\LMD の型推論アルゴリズム}
    型推論とは
    \begin{itemize}
        \item 入力: \LMD の項 $M$ と型環境 $\Gamma$
        \item 出力: \( \tau \) \hspace{10mm} (\( \Gamma \vdash M : \tau \)) \\
            \hspace{10mm} \hspace{2mm} {\tt Fail} \hspace{1mm} (そのような\( \tau \)が存在しないとき)
    \end{itemize}

    \onslide<2->{
        \begin{alertblock}{通常の型判断\( \Gamma \vdash M : \tau \)の問題点}
            通常の型判断\( \Gamma \vdash M : \tau \)の導出規則からは\\型推論アルゴリズムが構築できない
        \end{alertblock}
    }
\end{frame}

\begin{frame}[fragile]{アルゴリズム的型判断}
    \begin{itemize}
    \item 型推論アルゴリズムが停止する\\
        型判断\( \Gamma \AV M : \tau \)を新たに設計
    \item 更に以下を証明した
    \begin{itemize}
            \item \( \Gamma \AV M : \tau \) iff \( \Gamma \vdash M : \tau \)
    \end{itemize}

    \item ここからアルゴリズム的型判断を元に設計した\\型推論アルゴリズムの正当性が導かれる
    \end{itemize}
\end{frame}

\section{まとめ}

\begin{frame}{目次}
    \tableofcontents[currentsection]
\end{frame}


\begin{frame}[fragile]{関連研究}
    \begin{itemize}
        \item \LTP [Hanada\&Igarashi'14]
            \begin{itemize}
                    \item 本研究の拡張元
                    \item CSPを含む多段階計算体系
            \end{itemize}
        \item Concoqtion [Forgarty et al.'07]
            \begin{itemize}
                \item MetaOCamlに制限された形の依存型を導入
            \end{itemize}
        \item \( \lambda_{H\circ} \) [Pasalic'04]
            \begin{itemize}
                \item 依存型付きメタプログラミング言語
                \item コードの評価とCSPがない
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{結論}
    多段階計算に依存型を導入した
    \begin{itemize}
        \item 生成されたコードの不正な使用を依存型で防止
        \item \LMD の形式化
        \item 型安全性を証明 
        \item 型推論のアルゴリズムを設計 
    \end{itemize}
\end{frame}

% From here, I turned off the page number.
% Because these slides are for the Q and A time.
\setbeamertemplate{footline}{}

\begin{frame}[fragile, noframenumbering]{なぜ最初から$\Gamma \AV M : \tau$でやらないのか?}
    $\Gamma \vdash M : \tau$ と $\Gamma \AV M : \tau$ の比較 \\[5mm]
    \begin{tabular}{|c|c|c|} \hline
        & $\Gamma \vdash M : \tau$ & $\Gamma \AV M : \tau$ \\ \hline
        型安全性の証明 & 容易 & 困難 \\ \hline
        型推論アルゴリズム & 設計不可能 & 設計可能 \\ \hline
    \end{tabular}
\end{frame}

\begin{frame}[fragile, noframenumbering]{なぜ$\Gamma \V M : \tau$の導出規則から\\型推論アルゴリズムを設計できないのか?}
    構文主導(Syntax-directed)でない導出規則があるから
    \begin{center}
    {\footnotesize
        \infrule[\TConv]{\G\V M:\underline{\tau} @A \andalso \G\V \underline{\tau}\equiv \sigma :: K@A}{\G\V M:\sigma@A}
    }
    \end{center}
\end{frame}

% \begin{frame}[fragile]{\LTP の型}
%     \begin{block}{型}
%         \begin{tabbing}
%             \hspace{5mm} \( \tau \) \= ::= X \hspace{20mm} \= (intなどの型レベル定数) \\
%             \> \( \mid \TW\ \tau \) \> (コード型) \\
%             \> \( \mid \tau \to \tau \) \> (関数型)
%         \end{tabbing}
%     \end{block}
%
%     \begin{block}{型付け判断}
%         \begin{center}
%             \( \G \V M : \tau @ n \)
%         \end{center}
%         * 「型環境\( \G \)の下で項\( M \)に型\( \tau \)がステージ\( n \)でつく」\\
%         ** \( n \) はステージ.
%     \end{block}
% \end{frame}
%
% \begin{frame}[fragile]{ステージとは何か?}
%     項の外側にある \( \TB \) の数
%     \begin{exampleblock}{}
%         \begin{center}
%             \( \underbrace{\TB\ \overbrace{(\lambda x:\text{int}.x + 1)}^{\let\scriptstyle\textstyle\substack{\text{stage }1}}}_{\let\scriptstyle\textstyle\substack{\text{stage }0}} \)
%         \end{center}
%     \end{exampleblock}
%
%     \LTP の型判断と型環境はステージを含む
%     \begin{center}
%         \( x:\text{int}@1 \vdash x + 1 : \text{int} {\mathbf{@ 1}} \)
%     \end{center}
% \end{frame}
%
% \begin{frame}[fragile]{\LTP の型付け規則}
%     項を異なるステージの関数に適用できない
%     \begin{center}
%         {\footnotesize \infrule[\TApp]{
%             \G\V M:\sigma \to \tau @ n \andalso
%             \G\V N:\sigma @ n
%         }{
%             \G\V M\ N : \tau @ n
%         }}
%     \end{center}
%     \( \TB \)はステージを増加、\( \TBL \)はステージを減少させる
%     \begin{center}
%         {\footnotesize \infrule[{\TTB}]{
%             \G\V M:\tau @ n+1
%         }{
%             \G\V\TB M:\TW \tau @ n
%         } \hfil
%         \infrule[{\TTBL}]{
%             \G\V M:\TW \tau @ n
%         }{
%             \G\V\TBL M:\tau @ n + 1
%         }}
%     \end{center}
%     一般には異なるステージの項を使うことはできない
% \end{frame}
%
% \section{\LMD: \LTP の依存型による拡張}
%
% \begin{frame}{目次}
%     \tableofcontents[currentsection]
% \end{frame}
%
% \begin{frame}[fragile]{\LMD の概観}
%     \LTP の依存型による拡張
%     \begin{itemize}
%         \item \LMD の項は\LTP と同じ
%         \item 型は依存型で拡張されている
%         \item 型の間の同値関係を定義する規則がある
%     \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]{\LMD の型とカインド}
%     \LTP の型 + 依存型
%     \begin{block}{型}
%         \begin{tabbing}
%             \hspace{5mm} \( \tau \) \= ::= X \hspace{20mm} \= (型レベル定数) \\
%             \> \( \mid \TW\ \tau \) \> (コード型) \\
%             \> \( \bm{\mid \Pi x:\tau.\tau} \) \> (依存関数型) \\
%             \> \( \bm{\mid \tau\ M} \) \> (依存関数型への適用, e.g. \(\text{vec}\ 3\))
%         \end{tabbing}
%     \end{block}
%     \begin{block}{カインド(型の型)}
%         \( K ::= * \mid \Pi x:\tau.K \)
%     \end{block}
% \end{frame}
%
% \begin{frame}[fragile]{\LMD のカインド付け規則}
%     型は項を含みうるため、カインド付け判断もステージを含む
%     \begin{center}
%         \( \G \vdash \tau :: K @ n \)
%     \end{center}
%     \begin{center}
%         {\footnotesize
%         \infrule[{\KApp}]{
%             \G\V \sigma:: (\Pi x:\tau.K) @ n \andalso \G\V M:\tau @ n
%         }{
%             \G\V \sigma\ M::K[x\mapsto M] @ n
%         } \\[2mm]
%         \infrule[{\KAbs}]{
%             \G\V \tau :: * @ n \andalso \G,x:\tau@ n \V \sigma::*@n
%         }{
%             \G\V(\Pi x:\tau.\sigma) :: * @ n
%         }}
%     \end{center}
% \end{frame}
%
% \begin{frame}[fragile]{型の中のCSP}
%     コード型 \( \TW \) の中ではステージが1つ増える
%     \begin{center}
%         \infrule[{\KTW}]{
%             \G\V \tau::*@ n + 1
%         }{
%             \G\V\TW \tau::*@ n
%         }
%     \end{center}
%     このためコード型の外の変数\( n \)を\( \TW \)の中で使うためにはCSPが必要である
%     \begin{exampleblock}{}
%         \begin{tabbing}
%             \hspace{5mm} \= \text{val zeros} : \( \Pi n:\text{int}.(\text{vec}\ n) \) \\
%             \> \( \lambda n:\text{int}. (\TB (\% \text{zeros}\ \% n)): \underbrace{\Pi n:\text{int}. \TW (\overbrace{\text{vec}\ \%n}^{\text{stage }1})}_{\text{stage }0} \)
%         \end{tabbing}
%     \end{exampleblock}
% \end{frame}
%
% \begin{frame}[fragile]{\LMD の定数と型レベル定数}
%     \begin{itemize}
%         \item 定数: \( 0,1,2,3,\dots \)
%         \item 型レベル定数: int, vec, \dots
%     \end{itemize}
%     はどのステージでも使える
%     \begin{exampleblock}{}
%         \begin{tabbing}
%             \hspace{5mm} \= \text{val double-at-0} : \( \text{vec }3 \to \text{vec }3 \) \\[2mm]
%             \> \textbf{let } \text{double} = \( \TB (\%\ \text{double-at-0}) \) \\
%             \> \text{val double} : \( \TW \underbrace{(\text{vec }3 \to \text{vec }3)}_{\text{stage 1}} \)
%         \end{tabbing}
%     \end{exampleblock}
% \end{frame}
%
% \begin{frame}[fragile]{vadd3の技術的な問題}
%     他の関数と組み合わせるのが難しい
%     \newcommand{\Vn}{\text{vec}\ \%n}
%     \newcommand{\Vpt}{\text{vec}\ \%3}
%     \newcommand{\Vt}{\text{vec}\ 3}
%     \begin{exampleblock}{}
%     \begin{tabbing}
%         \hspace{5mm} \= \( \text{val}\ \text{vadd3} : \TW (\Vpt \to \Vpt \to \Vpt) \) \\
%         \> \( \text{val}\ \text{double} : \TW (\Vt \to \Vt) \) \\[2mm]
%         \> \( \textbf{let}\ \text{add-double}\ v\ w = \) \\
%         \> \hspace{5mm} \( \TB (\underbrace{\TBL\text{double}}_{\Vt \to \Vt}\ \underbrace{(\TBL \text{vadd3}\ \TBL v\ \TBL w)}_{\Vpt});; \) \\
%     \end{tabbing}
%     \end{exampleblock}
%     型が合わないので組み合わせることができない
% \end{frame}
%
% \begin{frame}[fragile]{解決}
%     \newcommand{\Vt}{\text{vec}\ 3}
%     \newcommand{\Vpt}{\text{vec}\ \%3}
%     \( M \) が閉じた項の場合に限りCSP(\%)を消すことを許す (\QPercent)
%     {\footnotesize{
%     \begin{center}
%         \infrule[{\QPercent}]{
%             M \text{ is a closed term.}
%         }{
%             \G\vdash \% M \E M
%         } \\[2mm]
%         \infrule[{\TConv}]{
%             \G\V M:\tau@n \andalso
%             \G\V \tau\equiv \sigma @n
%         }{
%             \G\V M:\sigma@n
%         }
%     \end{center}
%     }}
%     \begin{exampleblock}{}
%         \begin{itemize}
%             \item \( \text{vec}\ \%3 \E \text{vec}\ 3 \)
%             \item \( \text{vadd3} : \TW (\Vt \to \Vt \to \Vt) \) \\
%                 \hspace{15mm} \( (\E  \TW (\Vpt \to \Vpt \to \Vpt)) \)
%         \end{itemize}
%     \end{exampleblock}
% \end{frame}
%
% \begin{frame}[fragile]{性質}
%     以下の性質を証明した
%     \begin{itemize}
%         \item 代入補題
%         \item 強正規化性
%         \item 合流性
%         \item 進行性
%     \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]{関連研究}
%     \begin{itemize}
%         \item \LTP [Hanada\&Igarashi'14]
%         \item Concoqtion [Forgarty et al.'07]
%             \begin{itemize}
%                 \item MetaOCamlに制限された形の依存型を導入
%             \end{itemize}
%         \item \( \lambda_{H\circ} \) [Pasalic'04]
%             \begin{itemize}
%                 \item 依存型付きメタプログラミング言語
%                 \item コードの評価とCSPがない
%             \end{itemize}
%     \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]{結論}
%     多段階計算に依存型を導入した
%     \begin{itemize}
%         \item 依存型で生成されたコードの不正な仕様を防止
%             \begin{itemize}
%                 \item 制限されていない依存型
%             \end{itemize}
%         \item 同値関係を定義
%             \begin{itemize}
%                 \item 特にCSPについて
%             \end{itemize}
%         \item 型推論のアルゴリズムを設計 
%         \item 型健全性を証明 
%     \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]{Why a Stage is Needed?}
%     Without stage, \textbf{run} may causes a run-time error.
%     \begin{exampleblock}{}
%         \begin{center}
%     \( \TB (\lambda x:\tau. \TBL (\textbf{run}\ \TB x)) \)
%         \end{center}
%     \end{exampleblock}
%
%     With stage, the same code cannot be typed.\\
%     Because the subterm \( (\Lambda\alpha.\ \TB_\alpha x) \) is ill-typed.
%     \begin{exampleblock}{}
%         \begin{center}
%     \( \TB_\alpha (\lambda x:\tau. \TBL_\alpha ((\Lambda\alpha.\ \TB_\alpha x)\ \varepsilon)) \)
%         \end{center}
%     \end{exampleblock}
% \end{frame}

% \begin{frame}[fragile]{Styles of Multi-stage Programming}
%     \begin{itemize}
%         \item Strings
%             \begin{itemize}
%                     \item Ruby, Perl, etc.
%             \end{itemize}
%         \item ASTs
%             \begin{itemize}
%                     \item Lisp
%             \end{itemize}
%         \item ASTs and code types
%             \begin{itemize}
%                     \item MetaOCaml
%             \end{itemize}
%     \end{itemize}
%     \note{
%         There are three kinds of multi-stage Programming.
%     }
% \end{frame}

% \begin{frame}[fragile]{Generated functions by vadd-gen in \LMD}
%     Type system prevents illegal use of generated function.
%     \renewcommand{\V}{\text{vec}}
%     \begin{tabbing}
%         \( \text{vadd3}\ [1;2;3]\ [4;5;6];; \) \\
%         \( - : \V = [5;7;9] \) \\[2mm]
%         \( \text{vadd3}\ [1;2;3;4]\ [4;5;6;7];; \) \\
%         \( \longrightarrow \textbf{TYPE ERROR!} \text{ (not RUNTIME ERROR)} \)
%     \end{tabbing}
%     \note{
%         Type of generated functions by vadd-gen in \LMD have the length information in their types.
%     }
% \end{frame}

% \begin{frame}[fragile]{Terms of \LMD}
%     \begin{block}{Terms}
%         \( M ::= c \mid x \mid \lambda x:\tau.M\ \mid M\ M \mid \TB_\alpha M \mid \textbf{run}\ M \mid \TBL_\alpha M \)
%     \end{block}
%     \begin{itemize}
%         \item \( c \): constants
%             \begin{itemize}
%                     \item true, false, etc.
%             \end{itemize}
%         \item \( \TB_\alpha M \): code value
%         \item \( \textbf{run}\ M \): run a code value \( M \)
%             \begin{itemize}
%                 \item \( \textbf{run }(\text{vadd-gen }3)\)
%             \end{itemize}
%     \end{itemize}
%     \note{
%         Then, let me explain details of \LMD. \\
%         \( \TBL_\alpha M \) is not needed?
%     }
% \end{frame}

% \begin{frame}[fragile]{Types of \LMD}
%     \begin{block}{Types}
%     \( \tau,\sigma ::= X \mid \Pi x:\tau.\sigma \mid \tau\ M \mid \TW_{\alpha} \tau \mid \F\alpha.\tau \)
%     \end{block}
%     \begin{itemize}
%         \item \( X \): type-level constants 
%             \begin{itemize}
%                 \item \( \text{vec} \), \( \text{int} \).
%             \end{itemize}
%         \item \( \Pi x:\tau.\sigma \): dependent type.
%         \item \( \tau\ M \): Application of term to dependent type.
%             \begin{itemize}
%                 \item \( \text{vec } 3 \)
%             \end{itemize}
%         \item \( \TW_{\alpha} \tau \): a type of code of type \( \tau \).
%             \begin{itemize}
%                 \item \( \text{vadd-gen 3} : \TW_\alpha (\text{vec}\ 3 \to \text{vec}\ 3 \to \text{vec}\ 3) \)
%             \end{itemize}
%     \end{itemize}
%     \note{
%     }
% \end{frame}

% \begin{frame}[fragile]{Kinds of \LMD}
%     \begin{block}{Kinds}
%         \( K ::= * \mid \Pi x:\tau.K \)
%     \end{block}
%     \begin{itemize}
%         \item \( * \): kind of proper type
%             \begin{itemize}
%                 \item \( \text{int} :: * \)
%             \end{itemize}
%         \item \( \Pi x:\tau.K \): kind dependent on term.
%             \begin{itemize}
%                 \item \( \text{vec} :: (\Pi x:\text{int}.*) \)
%             \end{itemize}
%     \end{itemize}
%     \note{
%     }
% \end{frame}

% \begin{frame}[fragile]{Judgements of \LMD}
%     \begin{itemize}
%         \item \( \G \V K @ A \)
%             \begin{itemize}
%                 \item \( K \) is a proper kind under signature \( \Sigma \) at stage \( A \).
%             \end{itemize}
%         \item \( \G \V \tau :: K @ A \)
%             \begin{itemize}
%                 \item Type \( \tau \) has kind \( K \) under signature \( \Sigma \) at stage \( A \).
%             \end{itemize}
%         \item \( \G \V M : \tau @ A \)
%         \item \( \G \V K \E K' @ A \)
%             \begin{itemize}
%                 \item Kind \( K \) is equivalent to \( K' \) under signature \( \Sigma \) at stage \( A \).
%             \end{itemize}
%         \item \( \G \V \tau \E \tau' @ A \)
%         \item \( \G \V M \E M' @ A \)
%     \end{itemize}
%     \note{
%     }
% \end{frame}

% \begin{frame}[fragile]{What is stage\ \( A \)\ ?}
%     % I copied this underwrite macro from
%     % https://tex.stackexchange.com/questions/141932/how-to-write-under-an-underline.
%     % \underwrite[<thickness>]{<numerator>}{<denominator>}
%     \newcommand{\underwrite}[3][]{
%         \genfrac{}{}{#1}{}{\textstyle #2}{\textstyle #3}
%     }
%
%     Level of nested brankets
%     \begin{block}{Stages}
%         \( A := \varepsilon (\text{empty}) \mid \alpha \mid A\alpha \)
%     \end{block}
%     \begin{center}
%         \( \underbrace{(\textbf{run}\ (\TB_\alpha\ \overbrace{(2 + 3)}^{\let\scriptstyle\textstyle\substack{@\alpha}})) + 1}_{\let\scriptstyle\textstyle\substack{@\varepsilon}} \)
%     \end{center}
%     \note{
%         Stage is a sequence of stage variables which appended to each brack triangles.
%         \( \varepsilon \) means the empty sequence
%
%         The wholes expression is a term on stage \( \varepsilon \),
%         But subexpression in the brack triangle is a term on stage \( \alpha \).
%     }
% \end{frame}

% \begin{frame}[fragile]{What is signature \( \Sigma \)\ ?}
%     Signature \( \Sigma \) is a sequence of type-level constants and constant values.
%     \begin{itemize}
%         \item For example,
%             \begin{itemize}
%                 \item \( \Sigma = \text{int}::*, \text{vec}::\Pi x:\text{int}.*, 0:\text{int} \)
%             \end{itemize}
%         \item Elements of \( \Sigma \) can be used at any stages.
%     \end{itemize}
%     \note{
%         自然数が無限個あるというツッコミを誘発する気がする。
%         後者関数が存在することにするか?
%     }
% \end{frame}

% \begin{frame}[fragile]{Typing Rules of \LMD}
%     \begin{center}
%         \infrule[{\TTB}]{
%             \G\V M:\tau@{A\alpha}
%         }{
%             \G\V\TB_{\alpha}M:\TW_{\alpha}\tau@A
%         } \\[2mm]
%         \infrule[{\textsc{T-App}}]{
%             \G\V M:(\Pi (x:\sigma).\tau)@A \andalso
%             \G\V N:\sigma@A
%         }{
%             \G\V M\ N : \tau[x\mapsto N]@A
%         } \\[2mm]
%         \infrule[{\TConst}]{
%             c:\tau \in \Sigma \andalso
%         }{
%             \G \V c:\tau@A
%         }
%     \end{center}
%     \begin{itemize}
%         \item Terms are stage sensitive so cannot ignore stages.
%         \item Constants in \( \Sigma \) can be used at any stages.
%     \end{itemize}
%     \note{
%         Let's have a look on some typing rules.
%     }
% \end{frame}

% \begin{frame}[fragile]{Kinding Rules of \LMD}
%     \begin{center}
%         \infrule[{\KTW}]{
%             \G\V \tau::*@A\alpha
%         }{
%             \G\V\TW_\alpha \tau::*@A
%         }\\[2mm]
%         \infrule[{\KApp}]{
%             \G\V \sigma:: (\Pi x:\tau.K)@A \andalso \G\V M:\tau@A
%         }{
%             \G\V \sigma\ M::K[x\mapsto M]@A
%         }
%         \infrule[{\KTConst}]{
%             X::K \in \Sigma
%         }{
%             \G \V X::K@A
%         }
%     \end{center}
%     \begin{itemize}
%         \item Types are also stage sensitive.
%         \item Type-level constants in \( \Sigma \) can be used at any stages.
%     \end{itemize}
%     \note{
%         Kinding rules have something in common with typing rules.
%     }
% \end{frame}

% \begin{frame}[fragile]{Example of Kinding Derivation}
%     \renewcommand{\vec}{\text{vec}}
%     \( \V \TB_\alpha [1,2,3] : \underbrace{\TW_\alpha (\vec\ 3)}_{\TW_\alpha (\vec\ 3) :: * @ \varepsilon} @ \varepsilon \) \\[2mm]
%     \pause
%     \( \Sigma = \vec::\Pi x:\text{int}.*, 0:\text{int}, 1:\text{int}, \cdots \)
%     \begin{center}
%         \footnotesize
%         \begin{minipage}{0.7\hsize}
%             \infer[\KTW]
%             {\V \TW_\alpha (\vec\ 3) :: * @ \varepsilon}
%             {
%                 \infer[\KApp]
%                 {\V \vec\ 3 :: * @ \alpha}
%                 {
%                     \infer[\KTConst]
%                     {\V \vec :: \Pi x:\text{int}.* @ \alpha}
%                     {\vec :: \Pi x:\text{int}.* \in \Sigma}
%                     \andalso
%                     \infer[\TConst]
%                     {\V 3 : \text{int} @ \alpha}
%                     {3 : \text{int} \in \Sigma}
%                 }
%             }
%         \end{minipage}
%     \end{center}
%     We can use \vec\ and integers at any stages.
%     \note{
%         The constructed type vec 3 is stage sensitive so we cannot use at arbitrary stages
%         but the elements, vec and 3 are in the signature \( \Sigma \) and can be used at any stages.
%     }
% \end{frame}

% \begin{frame}[fragile]{Type and Term Equality Rules of \LMD}
%     \begin{center}
%         \footnotesize{
%             \infrule[{\QTApp}]{
%                 \G\V \tau \E \sigma :: (\Pi x:\rho.K)@A \andalso
%                 \G\V M \E N : \rho @A
%             }{
%                 \G\V \tau\ M \E \sigma\ N :: K[x \mapsto M]@A
%             } \\[2mm]
%             \infrule[{\QBeta}]{
%                 \G,x:\sigma@A\V M:\tau@A \andalso
%                 \G\V N:\sigma@A
%             }{
%                 \G\V(\lambda x:\sigma.M)\ N\E M[x\mapsto N] : \tau[x \mapsto N]@A
%             } \\[2mm]
%             \infrule[{\QPercent}]{
%                 \G\V M:\tau@{A\alpha} \andalso
%                 \G\V M:\tau@A
%             }{
%                 \G\V\%_\alpha M \E M : \tau@{A\alpha}
%             } \\[2mm]
%             \infrule[{\textsc{T-Conv}}]{
%                 \G\V M:\tau@A \andalso
%                 \G\V \tau\equiv \sigma :: K@A
%             }{
%                 \G\V M:\sigma@A
%             }
%         }
%     \end{center}
%     \note{
%     }
% \end{frame}

% \begin{frame}[fragile]{Examples of Type Equality}
%     \renewcommand{\V}{\text{vec}}
%     \begin{itemize}
%         \item \( (\lambda x:\text{int}.x)\ 3\E 3 \)
%             \begin{itemize}
%                 \item From \QBeta.
%             \end{itemize}
%         \item \( \V\ ((\lambda x:\text{int}.x)\ 3) \E \V\ 3 \)
%             \begin{itemize}
%                 \item From \QTApp and \QBeta.
%             \end{itemize}
%         \item \( \V\ (\%_\alpha 3) \E \V\ 3 \)
%             \begin{itemize}
%                 \item Because \( 3 \) has type \text{int} at any stage, we can use \QPercent.
%             \end{itemize}
%     \end{itemize}
%     \note{
%         Shold I show complete derivation tree?
%     }
% \end{frame}

\end{document}
